# FAQ

* [В чем преимущества БЭМ перед другими модульными решениями для CSS?](#bem-benefits)
* [В чем разница между БЭМ и Web Components? Что будет с БЭМ-методологией, если Web Components станет новым стандартом веб-разрабоки, принятым W3C?](#bem-vs-web-components)
* [При переходе на методологию БЭМ можно забыть о Bootstrap? В БЭМ есть всё, нужно только изучить?](#bem-vs-bootstrap)
* [Насколько БЭМ подходит для поддержки долгосрочных проектов?](#bem-for-huge-projects)
* [В каком случае создавать блок, в каком элемент?](#block-vs-elem)
* [Почему в БЭМ не рекомендуется создавать элементы элементов (`block__elem1__elem2`)?](#bem-elem-hierarchy)
* [Зачем нужен `i-bem.js`, если можно писать JavaScript для независимых блоков на привычном `jQuery`?](#i-bem-vs-JS)
* [Почему в БЭМ не приветствуются каскады в CSS?](#css-cascade)
* [Почему БЭМ использует длинные имена классов?](#long-name)
* [Почему в БЭМ не рекомендуется использовать комбинированные селекторы для создания CSS-правил к модификатору?](#comb-css)
* [Почему нельзя писать `<div class="block_mod">` вместо `<div class="block block_mod">`, если имя модификатора уже содержит всю информацию о блоке?](#block-name)
* [Можно ли создавать глобальные модификаторы для блоков?](#global-mod)
* [Почему БЭМ не рекомендует общий сброс стилей (reset)?](#global-reset)
* [Почему в БЭМ не используют пользовательские теги (custom tags) для формирования CSS-правил блока?](#tag-css)
* [Можно ли объединять тег и класс в селекторе (например, `button.button`)?](#tag-class-css)
* [Почему в названии модификатора не рекомендуется указывать предоставляемое им CSS-свойство?](#value-css)


**Не нашли ответ?** — [Задайте вопрос команде на форуме](https://ru.bem.info/forum/)

<a name="bem-benefits"></a>
## В чем преимущества БЭМ перед другими модульными решениями для CSS? 

>В веб-разработке используются разные модульные решения для CSS, например, OOCSS, AMCSS, SMACSS, SUITCSS. Почему стоит выбрать БЭМ для своего проекта?

Следует сразу отметить, что БЭМ-методология работает не только с CSS.

БЭМ — это компонентный подход к разработке в целом. Аналогично WEB Components он позволяет выражать интерфейс независимыми компонентами (блоками). Блок инкапсулирует в себе поведение (JavaScript), шаблоны, стили (CSS) и [технологии реализации](../../definitions/definitions.ru.md#bem-techs). Независимость блоков обеспечивает их повторное использование, а также удобство в разработке и поддержке проекта.

БЭМ-платформа предоставляет технологии, инструменты и готовые блоки. При использовании полного стека БЭМ-технологий вы получаете автоматизацию процессов, ускорение разработки за счет готовых компонент и оптимизацию финального кода.

Знакомство с БЭМ лучше всего начинать с CSS, так как при этом не требуется подключать дополнительные инструменты в проект. Необходимо только следовать рекомендациям методологии.

Если рассматривать БЭМ как модульное решение только для CSS, то такой подход позволяет создавать независимые блоки на уровне стилей. Такие блоки можно размещать в любом месте на странице, перемещать по странице и между проектами, вкладывать один в другой, комбинировать, при этом сохранять независимость CSS-селекторов. Изолированные CSS-стили и отказ от каскадов облегчают разработку и отладку проекта.

CSS по БЭМ дает явное понимание того, за какую часть интерфейса отвечает каждое правило, к какой БЭМ-сущности оно относится и от чего зависит. Вы получаете понятный и легко читаемый, самодокументируемый CSS-код.

<a name="bem-vs-web-components"></a>
## В чем разница между БЭМ и Web Components? Что будет с БЭМ-методологией, если Web Components станет новым стандартом веб-разрабоки, принятым W3C?

[Web Components](http://webcomponents.org) — это набор технических требований, которые позволяют разработчикам создавать компоненты интерфейса для повторного использования. Каждый компонент имеет свой внешний вид и логику поведения.

Такое верхнеуровневое определение подходит и для БЭМ-методологии.

Чтобы понять разницу, рассмотрим отдельные части Web Components и сравним с БЭМ:

* Custom Elements (пользовательские элементы). Позволяют создавать дополнительные элементы, которые используются наравне с другими DOM-элементами. К пользовательским элементам можно писать стили и скрипты. Если сравнивать с БЭМ, то Custom Elements решает ту же задачу, что и БЭМ-дерево — предоставляет абстракцию над DOM-деревом.

* HTML Imports (импорт HTML). Позволяет включать и повторно использовать код в других HTML-документах (аналогично импорту в CSS). Импорт HTML требует сборки («вулканизации» в терминах Web Components). В БЭМ задачу импорта решают шаблоны, а для сборки пакетов используется один из сборщиков: [ENB](https://ru.bem.info/tools/bem/enb-bem-examples/) или [bem-tools](https://ru.bem.info/tools/bem/bem-tools/). 

* Templates (шаблоны). Создают фрагменты разметки, с базовой структурой и возможностью ввода динамического содержимого, используя JavaScript. В БЭМ эти задачи решают шаблонизаторы, например, BEMHTML или BH.

* Shadow DOM (теневая модель документа). Реализует инкапсуляцию в DOM-дереве. Является частью документа и встраивается непосредственно внутрь страницы. В БЭМ для инкапсуляции в DOM-дереве служат элементы блоков.

БЭМ и Web Components решают одни и те же задачи. Важное отличие в том, что работа БЭМ не зависит от поддержки браузеров. В то время как для Web Components совместимость с браузерами необходима.

Значительные отличия есть и в использовании шаблонов. Применение Templates из Web Components предполагает внесение всего кода на страницу с добавлением стилей и вставкой «заглушек» в местах вывода переменных. JavaScript для работы шаблонов пишется отдельно. При таком подходе до момента выполнения JavaScript-кода неизбежно возникают проблемы с индексацией страницы поисковыми системами.

Плюсом Web Components считается увеличение скорости работы проекта. Но чтобы обработать шаблоны, заполнить их данными, сгенерировать финальный HTML и вставить его в DOM по-прежнему тратится время. Выигрыш по скорости возможен только за счет шаблонизации по принципу интерполяции строк. Но такие шаблоны не позволяют выражать все необходимые сценарии.

При использовании BEMHTML или BH генерация шаблона возможна на этапе разработки. Результат выполнения внедряется в готовый проект. Шаблоны Web Components такого сделать не позволяют.

В разработке проекта можно попытаться совместить практики Web Components и БЭМ. Например, при необходимости в БЭМ можно изменить шаблоны таким образом, чтобы генерировать блоки в виде веб-компонентов. Однако, стоит задуматься, какую практическую пользу это принесет. БЭМ уже сейчас используется в проектах и предоставляет готовые решения существующих проблем.

<a name="bem-vs-bootstrap"></a>
## При переходе на методологию БЭМ можно забыть о Bootstrap? В БЭМ есть всё, нужно только изучить?

[Bootstrap](http://getbootstrap.com/) — это набор сверстанных блоков, если говорить в терминах БЭМ. Таким образм уместно сравнивать Bootstrap и библиотеку [bem-components](https://ru.bem.info/libs/bem-components/current/), а не методологию. Сейчас в bem-components меньше блоков, чем в Bootstrap. Но существует еще [ряд БЭМ-библиотек](https://ru.bem.info/libs/), которые в сумме дают почти тот же набор.

При этом Boostrap, в отличие от БЭМ методологии, не предоставляет готовых решений по созданию архитектуры проекта, написанию новых блоков, масштабированию разработки по людям. Boostrap предлагает готовые компоненты страницы (кнопки, поля ввода, переключатели).

БЭМ, в первую очередь, решает задачу обеспечения гибкой разработки и повторного использования компонент, позволяет строить удобные в поддержке долговечные проекты. А готовые компоненты и инструментарий, построенные по методологии — это один из способов ее реализации на практике.

<a name="bem-for-huge-projects"></a>
## Насколько БЭМ подходит для поддержки долгосрочных проектов?

Удобство поддержки проектов — одна из главных целей БЭМ.

Изначально БЭМ-методология создавалась для упрощения работы в больших долгосрочных проектах.

>[История создания БЭМ](../../history/history.ru.md)

Сегодня БЭМ используется для создания и поддержки проектов разного уровня сложности и объема.

Распространенные проблемы в поддержке долгосрочных проектов вызваны, в первую очередь, сильной связанностью кода, отсутствием актуальной внутрипроектной документации и меняющейся командой разработчиков.

Методология БЭМ решает эти проблемы.

Основа БЭМ-проекта — это блоки — логически и функционально независимые компоненты страницы. Блок инкапсулирует свои данные, что позволяет скрыть его внутреннюю реализацию (логику, стили, шаблоны). Так достигается независимость блоков. При отладке проекта, изменения вносятся локально в каждый отдельный блок, что позволяет избежать нежелательного влияния на другие компоненты страницы.

В БЭМ каждый блок может быть представлен в одной или сразу нескольких [технологиях](../../definitions/definitions.ru.md#bem-techs), которые всегда размещаются в папке этого блока в файловой системе.

>[Организация файловой системы БЭМ-проекта](../../file-system/file-system.ru.md)

Рассмотрим пример логотипа (блок `logo`), который реализован с помощью шаблона и стилей. В файловой системе структура блока выглядит так:

```
logo/
    ├──logo.bemhtml
    └──logo.css
```

Добавим логотипу логику (JavaScript). Файл logo.js также будет создан в папке блока `logo`:

```
logo/
    ├──logo.bemhtml
    ├──logo.css
    └──logo.js
```

Такая структура позволяет при повторном использовании или отладке блока находить его технологии реализации и вносить изменения, не тратя время на изучение кода всей страницы. В отличие от классической веб-разработки, где весь CSS-код пишется в папке `css/`, а JavaScript — в `js/`.

Соблюдение [правил по именованию БЭМ](../../naming/naming.ru.md) решает [проблемы со связанностью кода в CSS](../fixed-problems.ru.md) и позволяет писать изолированные CSS-селекторы к блокам.

Явные имена БЭМ-сущностей и понятная структура файловой системы облегчают погружение в проект новых членов команды. А независимость блоков снижает вероятность получения побочных эффектов при отладке кода.

<a name="block-vs-elem"></a>
## В каком случае создавать блок, в каком элемент?

Разделение на блоки и элементы в БЭМ-методологии происходит по следующему принципу: 

* блок — всегда независимый компонент страницы, который можно использовать повторно (аналогия — компонента в Web Components);
* элемент — часть блока, которая не может использоваться вне контекста блока (аналогия — Shadow DOM в Web Components).

Определить, какую БЭМ-сущность создавать в каждой конкретной ситуации, помогут два правила:

1. Если фрагмент кода может использоваться повторно вне контекста родителя, необходимо создавать блок.
1. Если фрагмент кода не может функционировать без родительской сущности, в большинстве случаев создается элемент.

Исключение составляют элементы со сложной, расширенной функциональностью. Для удобства может понадобиться сделать его собственные элементы. Тогда такой сложный элемент можно представить как служебный «приватный» блок.

<a name="bem-elem-hierarchy"></a>
## Почему в БЭМ не рекомендуется создавать элементы элементов (`block__elem1__elem2`)?

>В объяснении приводятся названия БЭМ-сущностей, основанные на [соглашении по именованию БЭМ](../../naming/naming.ru.md).

В БЭМ-методологии вложенную структуру поддерживают только блоки (`block__elem`). Имя блока обеспечивает пространство имен, которое гарантирует зависимость элементов только от блока.

Блок может иметь вложенную структуру элементов в DOM-дереве:

```html
<div class='block'>
    <div class='block__elem1'>
        <div class='block__elem2'>
            <div class='block__elem3'></div>
        </div>
    </div>
</div>
```

Однако эта же структура блока в БЭМ-методологии всегда будет представлена плоским списком элементов:

```css
.block{}
.block__elem1{}
.block__elem2{}
.block__elem3{}
```

Это позволяет изменять DOM-структуру блока без внесения правок в коде каждого отдельного элемента.

```html
<div class='block'>
    <div class='block__elem1'>
        <div class='block__elem2'></div>
    </div>
    <div class='block__elem3'></div>
</div>
```

<a href="i-bem-vs-JS"></a>
## Зачем нужен `i-bem.js`, если можно писать JavaScript для независимых блоков на привычном jQuery?

Такой вариант возможен. Более того, `i-bem.js` написан с использованием jQuery.

Разработка по БЭМ требовала решения одних и тех же задач на JavaScript в терминах блоков, элементов и модификаторов. Это приводило к регулярному повторению одних и тех же действий. Чтобы автоматизировать процесс и избавиться от «копипаста», а также предоставить удобные хелперы пользователям, был написан [i-bem.js](https://ru.bem.info/technology/i-bem/).

<a name="css-cascade"></a>
## Почему в БЭМ не приветствуются каскады в CSS?

Применение каскада увеличивает связанность кода и делает его повторное использование невозможным. Это противоречит принципам БЭМ. Согласно методологии стили для каждой БЭМ-сущности должны быть прописаны отдельно, независимо.

Методология БЭМ допускает использование каскадов, но рекомендует по-максимуму его сократить.

Например, каскад уместен, чтобы менять элементы в зависимости от состояния блока или заданной ему темы:

```css
.nav_hovered .nav__link
{
    text-decoration: underline;
}
```
```css
.nav_theme_islands .nav__item
{
    line-height: 1.5;
}
```

<a name="long-name"></a>
## Почему БЭМ использует длинные имена классов?

БЭМ не запрещает использовать `btn` вместо `button`. Как раз наоборот, методология позволяет выбрать любую удобную для проекта стратегию именования. Например, все варианты верны: `context`, `ctx` или `c`, `attributes`, `attrs` или `as`. Важно выбрать один из них и использовать консистентно во всем проекте.

Имена элементов и модификаторов все же могут казаться новичкам неоправданно длинными (`btn_hvrd` и `btn__txt`). Есть два основных довода в пользу использования таких имен:

* Уникальное имя блока в именах элементов и модификаторов обеспечивает пространство имен и позволяет защитить элементы от взаимного влияния друг на друга. Элементы всегда являются частью блока и не могут взаимодействовать с окуржающими блоками, аналогично Shadow DOM в Web Components.

* Именам CSS-селекторов в БЭМ уделяется такое же внимание, как и именам переменных в JavaScript. Понятные, легко масштабируемые названия БЭМ-сущностей должны облегчать отладку кода не только в JavaScript, но и в CSS.

<a name="comb-css"></a>
## Почему в БЭМ не рекомендуется использовать комбинированные селекторы для создания CSS-правил к модификатору?

>Комбинированый селектор `.block.mod` позволяет корректно написать CSS к модификатору. Почему нельзя применять модификатор к блоку, используя сокращенную форму записи `<div class="block mod">` вместо рекомендуемой`<div class="block block_mod">`?

Необходимость указывать блок в имени модификатора имеет ряд причин:

**Избегаем неоднозначности**

В БЭМ распространено использование миксов — совмещение разных БЭМ-сущностей на одном DOM-узле. При миксе модификатора, нужна гарантия, что он окажет влияние только на ту БЭМ-сущность, к которой он относится.

Например, рассмотрим микс пункта меню (`menu__item`) и кнопки (`button`). В HTML это будет выглядеть так:

HTML
```html
<div class="menu__item button"></div>
```

Добавим модификатор `active` в сокращенной форме записи:

HTML
```html
<div class="menu__item button active"></div>
```

Если не указывать имя блока, то модификатор окажет влияние на обе БЭМ-сущности.

В такой форме записи HTML-разметка не дает понять, к чему относится модификатор: к пункту меню (`menu__item.active`) или к кнопке (`button.active`). Использование имени блока (`button_active`) явно указывает на БЭМ-сущность, к которой будет применен модификатор.

**Повышаем специфичность селекторов**

Чем выше специфичность селектора, тем выше его приоритет.
Комбинированные селекторы имеют более высокую специфичность в CSS, чем одиночные. Это означает, что при переопределнии одиночного селектора модификатора с помощью родительского блока возникнут трудности.

Рассмотрим пример:

```html
<div class="header">
  <button class="button active">
</div>
```
Правила модификатора `active` для кнопки будут записаны как комбинированный селектор `.button.active`. При переопределнии кнопки с помощью родительского блока `header`, будет создан селектор `.header .button`. Специфичность обоих селекторов одинакова, значит применение CSS-правил будет зависеть только от порядка их объявления в декларации.

Использование имени блока в названии модификатора обеспечивает более высокий приоритет CSS-правилам при переопределении блока. Селектор `.header .button` всегда будет иметь приоритет выше, чем `.button_active`.

**Создаем понятную структуру блока**

Запись вида `<div class="block mod">` не дает явно понять, какие БЭМ-сущности используются в работе. По именам не всегда удается точно определить соответствие конкретной БЭМ-сущности. Так, из записи `<div class="checkbox button">` нельзя утверждать, это микс модификатора и блока или микс двух блоков. Применение сложных или сокращенных имен также может ввести в заблуждение.

Полное имя модификатора `<div class="block block_mod">` явно показывает, о каких сущностях идет речь: `<div class="checkbox checkbox_button">`.

Четкая структура блока также облегчает поиск необходимой сущности в коде и файловой системе.

Сравним результаты глобального поиска при рефакторинге проекта. Найдем модификатор `active`. В сокращенном виде (`active`) в результаты поиска попадут все возможные комбинации и HTML-фрагменты, где встречается `active`. В записи, рекомендуемой методологией, само название уже будет содержать уточняющий параметр в виде имени блока (`button_active`). Так как имя модификатора уникально, в результаты поиска попадут только нужные фрагменты.

<a name="block-name"></a>
## Почему нельзя писать `<div class="block_mod">` вместо `<div class="block block_mod">`, если имя модификатора уже содержит всю информацию о блоке?

Совмещение нескольких модификаторов на одном и том же блоке (например, `<div class="block_theme_christmas block_size_big">`) приведет к дублированию кода, реализующего базовую функциональность (логику и стили) блока.

<a name="global-mod"></a>
## Можно ли создавать глобальные модификаторы для блоков?

>Удобно создать общие правила для таких глобальных модификаторов, как как `visible`, `invisible`, `red`, `opacity50` в глобальном классе и применять его к разным блокам. Почему БЭМ это не использует?

В БЭМ нет понятия глобальных модификаторов.

Модификатор — это свойство определяющее внешний вид, состояние или поведение блока или элемента. Он всегда относится к одной конкретной БЭМ-сущности.

Таким образом, если есть необходимость вынести какое-то свойство за пределы одного блока и применять его к разным БЭМ-сущностям в проекте, необходимо создавать отдельный блок. Такой блок может быть реализован только в технологии CSS.

Функционально БЭМ позволяет использовать несколько классов на одном DOM-узле и таким образом совмещать реализацию разных блоков. Такое объединение БЭМ-сущностей называется [миксом](../definitions/definitions.ru.md#mix):

```html
<div class="block1 opacity50"></div>
```

<a name="global-reset"></a>
## Почему БЭМ не рекомендует общий сброс стилей (reset)?

>Глобальный сброс стилей — общепринятая практика в веб-разработке. Многие фреймворки перед началом работы приводят все к общему виду, а потом накладывают свои классы.

БЭМ-методология не запрещает использовать общий сброс стилей. Но рекомендует делать его в рамках основных БЭМ-принципов, сохраняя независимотсь блоков.

Общий сброс в CSS — это набор CSS-правил, который применяется к узлам документа и гарантирует их одинаковый внешний вид в разных браузерах. В большинстве случаев такие CSS-правила пишутся к селекторам на тег, что [не вполне подходит для БЭМ](#tag-css).

При необходимости в БЭМ используется сброс стилей, но реализуется он для каждого блока отдельно. Блок — это независимый компонент страницы, который инкапсулирует в себе все необходимое для своего функционирования и правильного отображения. Реализация блока не должна меняться при воздействии внешних факторов. Если блок не может выглядеть нужным образом без применения к нему сторонних CSS-правил, добавленных на страницу, то он не может быть независимым.

Рассмотрим пример. Если в проекте блоки меню и список в HTML выражены с помощью `<ul>`, значит каждый блок должен предоставлять сброс CSS для `<ul>`. Повторов в результируеющем коде можно избежать с помощью CSS-оптимизатора.

Если в проекте не испльзуется CSS-оптимизатор, который объединяет селекторы с одинаковым набором правил, можно применить CSS-препроцессор. Тогда для каждого нового блока можно делать сброс правил, миксуя чистый код. Например, в SASS это будет выглядеть так:

```
.menu {
    @include reset-list;
}
.menu__item {
    @include reset-list-item;
}
...
.list {
    @include reset-list;
}
.list__item {
    @include reset-list-item;
}
```

Такой способ следует использовать только при отсутсвии оптимизатора.

<a name="tag-css"></a>
## Почему в БЭМ не используют пользовательские теги (custom tags) для формирования CSS-правил блока?

>Блоки могут выражаться в HTML с помощью пользовательских тегов, к которым создаются CSS-правила. На первый взгляд, селекторы на тег могут полностью заменить CSS-классы для блоков. В таком случае классы можно будет использовать только для выражения модификаторов: `<button class="mod"/>`.

Применение пользовательских тегов в качестве селекторов для блока может рассматриваться, как один из вариантов использования БЭМ-методологии. Однако этот подход менее гибкий в отличие от рекомендованного применения классов.

Использование селекторов на тег влечет ряд ограничений:

* Зависимость от тега делает невозможным использование миксов — размещения нескольких БЭМ-сущностей на одной DOM-ноде. А классы дают возможность свободно совмещать любые БЭМ-сущности: `<div class="block1 block2">`.
* Использование тегов не всегда дает возможность выразить любой блок отдельным, уникальным тегом. Например, для ссылок всегда необходим тег <a>, а для полей — <input>.

<a name="tag-class-css"></a>
## Можно ли объединять тег и класс в селекторе? Например, `button.button`.

Совмещение тега и класса в селекторе повышает его специфичность. Это усложняет переопределение блока.

При добавлении модификатора, селектор `.button_mod` не переопределит свойства блока, записанные как `button.button`, так как специфичность `button.button` выше. Для успешного переопределения модификатор блока также должен быть скомбинирован с тегом `button.button_mod`.

В развивающемся в проекте может появится `input.button`, `span.button` и, например, `a.button`. И все модификаторы блока `button` и вложенные в него элементы потребуют четыре разные декларации для каждого случая.

<a name="value-css"></a>
## Почему в названии модификатора не рекомендуется указывать предоставляемое им CSS-свойство?

>Количество модификаторов неограничено, значит для блоков можно создать разные модификаторы, предоставляющие определенные CSS-свойства. Например, селектор `.block__element_border-bottom_5px`. 

БЭМ-методология рекомендует выбирать семантически обоснованные имена для модификаторов, даже если они содержат только одно свойство.

Причины, по которым не следует указывать в названии модификатора его CSS-свойство:

* Изменение внешнего вида компонентов страницы повлекут за собой правки не только CSS-кода, но и названий селекторов и модификаторов. Например, если граница изменится с 5px до 6px, придется менять все шаблоны и, вполне вероятно, JavaScript.
* Наличие у модификатора только одного CSS-свойства — это скорее исключение, чем правило. Если модификатор отвечает только за размер границ блока, нет гарантий, что это не изменится. В будущем может понадобиться добавить дополнительные свойства. Например, выставление этого модификатора будет влиять на фон и отступы. В таком случае имя модификатора `_border-bottom_5px` не будет соответствовать действительности.
