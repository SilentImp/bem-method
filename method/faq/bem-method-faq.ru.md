# FAQ

## Общие вопросы по методологии

* [В чем преимущества БЭМ перед другими модульными решениями для CSS?](#bem-benefits)
* [В чем разница между БЭМ и Web Components? Что будет с БЭМ-методологией, если Web Components станет новым стандартом веб-разработки, принятым W3C?](#bem-vs-web-components)
* [При переходе на методологию БЭМ можно забыть о Bootstrap? В БЭМ есть всё, нужно только изучить?](#bem-vs-bootstrap)
* [Насколько БЭМ подходит для поддержки долгосрочных проектов?](#bem-for-huge-projects)
* [В каком случае создавать блок, в каком — элемент?](#block-vs-elem)
* [Почему в БЭМ не рекомендуется создавать элементы элементов (`block__elem1__elem2`)?](#bem-elem-hierarchy)

## БЭМ и JavaScript

* [Зачем нужен `i-bem.js`, если можно писать JavaScript для независимых блоков на привычном `jQuery`?](#i-bem-vs-JS)

## БЭМ и CSS

* [Почему в БЭМ не приветствуются каскады в CSS?](#css-cascade)
* [Почему БЭМ использует длинные имена классов?](#long-name)
* [Почему нельзя применять модификатор к блоку, используя сокращенную форму записи `<div class="block mod">` вместо рекомендуемой`<div class="block block_mod">`? Комбинированый селектор `.block.mod` позволяет корректно написать CSS к модификатору.](#short-mod-name)
* [Почему в БЭМ не рекомендуется использовать комбинированные селекторы для создания CSS-правил к модификатору? Это позволило бы избежать указания имени блока в имени модификатора.](#comb-css)
* [Можно ли объединять тег и класс в селекторе (например, `button.button`)?](#tag-class-css)
* [Почему нельзя писать `<div class="block_mod">` вместо `<div class="block block_mod">`, если имя модификатора уже содержит всю информацию о блоке?](#block-name)
* [Можно ли создавать глобальные модификаторы для блоков?](#global-mod)
* [Почему БЭМ не рекомендует общий сброс стилей (reset)?](#global-reset)
* [Почему в БЭМ не используют пользовательские теги (custom tags) для формирования CSS-правил блока?](#tag-css)
* [Почему в названии модификатора не рекомендуется указывать предоставляемое им CSS-свойство (например, `.block__element_border-bottom_5px`)?](#value-css)


**Не нашли ответ?** — [Задайте вопрос команде на форуме](https://ru.bem.info/forum/)

<a name="bem-benefits"></a>
## В чем преимущества БЭМ перед другими модульными решениями для CSS? 

>В веб-разработке используются разные модульные решения для CSS, например, OOCSS, AMCSS, SMACSS, SUITCSS. Почему стоит выбрать БЭМ для своего проекта?

БЭМ, как модульное решение для CSS, позволяет:

* создавать независимые блоки на уровне стилей;
* сохранять независимость CSS-селекторов при любых манипуляциях с блоками;
* писать понятный, легко читаемый, самодокументируемый CSS-код;
* размещать блоки в любом месте на странице;
* перемещать блоки по странице и между проектами;
* вкладывать один блок в другой;
* комбинировать различные блоки;
* облегчать разработку и отладку проекта.

Перечисленные модульные решения для CSS предоставляют похожие возможности. Однако они не предлагают комплексного решения для вашего проекта, так как работают только с CSS. В БЭМ единые правила именования сущностей, основанные на использовании классов, позволяют связать CSS и JavaScript вашего проекта. БЭМ-методология — это компонентный подход к разработке в целом. Аналогично Web Components он позволяет выражать интерфейс независимыми компонентами (блоками), которые инкапсулирует в себе поведение (JavaScript), шаблоны, стили (CSS) и [технологии реализации](../../definitions/definitions.ru.md#bem-techs).

Знакомство с БЭМ лучше всего начинать с CSS, так как при этом не требуется изучения дополнительных инструментов. Необходимо только следовать рекомендациям.

>[Соглашение по именованию CSS-селекторов](../naming/naming.ru.md)

>[Решение распространенных проблем веб-разработки с помощью БЭМ](../fixed-problems.ru.md)

<a name="bem-vs-web-components"></a>
## В чем разница между БЭМ и Web Components? Что будет с БЭМ-методологией, если Web Components станет новым стандартом веб-разработки, принятым W3C?

БЭМ и [Web Components](http://webcomponents.org) решают примерно одни и те же задачи: позволяют разработчикам создавать компоненты интерфейса для повторного использования. Однако в реализации существует ряд различий.

#### Различия

**Использование шаблонов**

*Web Components*

* Применение Templates предполагает внесение всего кода на страницу с добавлением стилей и вставкой «заглушек» в местах вывода переменных. JavaScript-код для работы шаблонов пишется отдельно.<br>
При таком подходе до момента выполнения JavaScript-кода неизбежно возникают проблемы с индексацией страницы поисковыми системами.
* Шаблонизация по принципу интреполяции строк позволяет увеличить скорость работы проекта. Однако на обработку шаблонов, заполнение их данными, генерацию финального HTML и встраивание его в DOM по-прежнему необходимо время.<br>
Такие шаблоны не позволяют выражать все необходимые сценарии.

*БЭМ*

* При использовании BEMHTML или BH генерация шаблона возможна на этапе разработки. Результат выполнения внедряется в готовый проект.

**Зависимость от поддержки браузеров**

*Web Components*

* Зависит от [совместимости с браузерами](http://caniuse.com/#search=Web%20Components). На сегодняшний день браузеры Safari, iOS Safari, Internet Explorer, Firefox не поддерживают работу Web Components.

*БЭМ*

* Работа БЭМ не зависит от поддержки браузеров.

<a name="principles"></a>
#### Общие принципы работы

Рассмотрим отдельные части Web Components и сравним с БЭМ:

* Custom Elements (пользовательские элементы). Позволяют создавать дополнительные элементы, которые используются наравне с другими DOM-элементами. К пользовательским элементам можно писать стили и скрипты.<br>
В **БЭМ** задачи Custom Elements решает БЭМ-дерево — предоставляет абстракцию над DOM-деревом.

* HTML Imports (импорт HTML). Позволяет включать и повторно использовать код в других HTML-документах (аналогично импорту в CSS). Импорт HTML требует сборки («вулканизации» в терминах Web Components).<br>
В **БЭМ** задачу импорта решают шаблоны, а для сборки пакетов используется один из сборщиков: [ENB](https://ru.bem.info/tools/bem/enb-bem-examples/) или [bem-tools](https://ru.bem.info/tools/bem/bem-tools/). 

* Templates (шаблоны). Создают фрагменты разметки с базовой структурой и возможностью ввода динамического содержимого, используя JavaScript.<br>
В **БЭМ** эти задачи решают шаблонизаторы, например, [BEMHTML](https://ru.bem.info/technology/bemhtml/v2/rationale/) или [BH](https://ru.bem.info/technology/bh/v4.1.0/about/).

* Shadow DOM (теневая модель документа). Реализует инкапсуляцию в DOM-дереве. Является частью документа и встраивается непосредственно внутрь страницы.<br>
В **БЭМ** для инкапсуляции в DOM-дереве служат элементы блоков.

#### Будущее Web Components и БЭМ

В случае признания Web Components новым стандартов в веб-разработке, существует возможность совместить практики Web Components и БЭМ. Например, можно изменять шаблоны таким образом, чтобы генерировать блоки в виде веб-компонентов.

<a name="bem-vs-bootstrap"></a>
## При переходе на методологию БЭМ можно забыть о Bootstrap? В БЭМ есть всё, нужно только изучить?

В терминах БЭМ [Bootstrap](http://getbootstrap.com/) — это набор сверстанных блоков. В отличие от БЭМ методологии он не предоставляет решений по созданию архитектуры проекта, написанию новых блоков, совместной разработке и отладке проекта.

Таким образом уместно сравнивать Bootstrap и библиотеку [bem-components](https://ru.bem.info/libs/bem-components/current/), а не методологию.

bem-components предоставляет [набор готовых визуальных компонентов](https://ru.bem.info/libs/bem-components/v2.2.0/#blocks), который может быть расширен блоками из других [БЭМ-библиотек](https://ru.bem.info/libs/).

<a name="bem-for-huge-projects"></a>
## Подходит ли БЭМ для поддержки долгосрочных проектов?

БЭМ-методология не только подходит для поддержки долгосрочных проектов, она [изначально разрабатывалась](#https://ru.bem.info/method/history/) с этой целью.

БЭМ решает основные проблемы долгосрочных проектов, вызванные следующими факторами:

* сильной связанностью кода;
* отсутствием актуальной внутрипроектной документации;
* меняющейся командой разработчиков.

Удобная поддержка и разработка БЭМ-проекта обеспечивается за счет:

* разделения страницы на логически и функционально независимые компоненты — [блоки](../definitions/definitions.ru.md#block);
* соблюдения [общих правил именования БЭМ-сущностей](../../naming/naming.ru.md);
* [организации файловой системы](../../file-system/file-system.ru.md).

БЭМ-методология позволяет:

* вносить изменения локально в каждый отдельный блок;
* писать изолированные CSS-селекторы, шаблоны и логику (Java-Script) к блокам;
* создавать понятную структуру файловой системы;
* снизить вероятность получения побочных эффектов при отладке кода за счет независимости блоков;
* облегчить погружение в проект новых членов команды благодаря единым правилам именования и прозрачной файловой структуре.

<a name="block-vs-elem"></a>
## В каком случае создавать блок, в каком элемент?

Определить, какую БЭМ-сущность создавать в каждой конкретной ситуации, помогут следующие правила:

1. Если фрагмент кода может использоваться повторно вне контекста родителя, необходимо создавать [блок](../definitions/definitions.ru.md#block).
1. Если фрагмент кода не может функционировать без родительской сущности, в большинстве случаев создается [элемент](../definitions/definitions.ru.md#elem).

Исключение составляют элементы, реализация которых для упрощения разработки требует разделения на более мелкие части — подэлементы. БЭМ-методология [не рекомендует делать элементы элементов](#bem-elem-hierarchy). В подобном случае вместо элемента необходимо создавать служебный «приватный» блок.

<a name="bem-elem-hierarchy"></a>
## Почему в БЭМ не рекомендуется создавать элементы элементов (`block__elem1__elem2`)?

>В объяснении приводятся названия БЭМ-сущностей, основанные на [соглашении по именованию БЭМ](../../naming/naming.ru.md).

В БЭМ-методологии вложенную структуру поддерживают только блоки (`block__elem`). Имя блока задает пространство имен, которое гарантирует зависимость элементов от блока.

Блок может иметь вложенную структуру элементов в DOM-дереве:

```html
<div class='block'>
    <div class='block__elem1'>
        <div class='block__elem2'>
            <div class='block__elem3'></div>
        </div>
    </div>
</div>
```

Однако эта же структура блока в БЭМ-методологии всегда будет представлена плоским списком элементов:

```css
.block{}
.block__elem1{}
.block__elem2{}
.block__elem3{}
```

Это позволяет изменять DOM-структуру блока без внесения правок в коде каждого отдельного элемента:

```html
<div class='block'>
    <div class='block__elem1'>
        <div class='block__elem2'></div>
    </div>
    <div class='block__elem3'></div>
</div>
```

<a href="i-bem-vs-JS"></a>
## Зачем нужен `i-bem.js`, если можно писать JavaScript-код для независимых блоков на привычном jQuery?

[i-bem.js](https://ru.bem.info/technology/i-bem/v2/i-bem-js/) — это специализированный фреймворк для веб-разработки по БЭМ-методологии. Он не предназначен для замены фреймворка общего назначения, такого как jQuery.

`i-bem.js` написан с использованием jQuery для удобства разработки в БЭМ-терминах.

`i-bem.js` позволяет:

* разрабатывать веб-интерфейс в терминах блоков, элементов, модификаторов;
* интегрировать JavaScript-код с шаблонами и CSS-правилами в стиле БЭМ;
* описывать логику работы блока как набор состояний.

<a name="css-cascade"></a>
## Почему БЭМ не рекомендует использовать каскады в CSS?

Применение каскада увеличивает связанность кода и делает его повторное использование невозможным. Это противоречит принципам БЭМ. Согласно методологии стили для каждой БЭМ-сущности должны быть заданы отдельно, независимо.

Методология БЭМ допускает использование каскадов, но рекомендует по-максимуму его сократить.

Например, каскад уместен, чтобы менять элементы в зависимости от состояния блока или заданной ему темы:

```css
.nav_hovered .nav__link
{
    text-decoration: underline;
}
```
```css
.nav_theme_islands .nav__item
{
    line-height: 1.5;
}
```

<a name="long-name"></a>
## Почему БЭМ использует длинные имена классов?

Причины применения [правил именования по БЭМ](../naming/naming.ru.md) (например, `btn_hvrd` и `btn__txt`):

* Имя блока задает пространство имен и обеспечивает уникальность имен элементов и модификаторов. Это позволяет защитить элементы от взаимного влияния друг на друга.

* Явные и уникальные имена облегчают поиск необходимой сущности в коде и файловой системе.<br>
Сравним результаты глобального поиска при рефакторинге проекта. Найдем модификатор `active`. В сокращенном виде (`active`) в результаты поиска попадут все возможные комбинации и HTML-фрагменты, где встречается `active`. В записи, рекомендуемой методологией, само название уже будет содержать уточняющий параметр в виде имени блока (`button_active`). Так как имя модификатора уникально, в результаты поиска попадут только нужные фрагменты кода.

> **Важно!** Методология БЭМ [допускает выбор](../naming/naming.ru.md#name-scheme) удобной стратегии именования, но требует соблюдения консистентности в названиях. Так, например, все варианты верны: `context`, `ctx` или `c`, `attributes`, `attrs` или `as`. Необходимо выбрать один из них и использовать во всем проекте.

<a name="short-mod-name"></a>
## Почему нельзя применять модификатор к блоку, используя сокращенную форму записи `<div class="block mod">` вместо рекомендуемой `<div class="block block_mod">`? Комбинированый селектор `.block.mod` позволяет корректно написать CSS к модификатору.

Основной причиной использования записи вида `<div class="block block_mod">` является применение [миксов](../definitions/definitions.ru.md#mix) — совмещения разных БЭМ-сущностей на одном DOM-узле.

При миксе модификатора, нужна гарантия, что он окажет влияние только на ту БЭМ-сущность, к которой он относится.

Например, рассмотрим микс пункта меню (`menu__item`) и кнопки (`button`):

HTML
```html
<div class="menu__item button"></div>
```

Добавим модификатор `active` в сокращенной форме записи (без имени блока):

HTML
```html
<div class="menu__item button active"></div>
```

Если не указывать имя блока, то модификатор окажет влияние на обе БЭМ-сущности.

В таком виде HTML-разметка не дает понять, к чему относится модификатор: к пункту меню (`menu__item.active`) или к кнопке (`button.active`). Использование имени блока (`button_active`) явно указывает на БЭМ-сущность, к которой будет применен модификатор.

Также запись `<div class="block mod">` не дает понять, какие БЭМ-сущности используются в работе. По именам не всегда удается точно определить соответствие конкретной БЭМ-сущности. Например, из записи `<div class="checkbox button">` нельзя однозначно понять, это микс модификатора и блока или микс двух блоков.

Полное имя модификатора `<div class="block block_mod">` показывает, о каких сущностях идет речь: `<div class="checkbox checkbox_button">`.

>[Дополнительные причины](#comb-css) обязательного использования имени блока в имени модификатора.

<a name="comb-css"></a>
## Почему в БЭМ не рекомендуется использовать комбинированные селекторы для создания CSS-правил к модификатору? Это позволило бы избежать указания имени блока в имени модификатора.

Комбинированные селекторы имеют более высокую специфичность в CSS, чем одиночные. Чем выше специфичность селектора, тем выше его приоритет. Это означает, что специфичность комбинированного селектора для модификатора блока (`.block1.mod`) и для переопределенного блока (`.block2 .block1`) будет одинакова. Приоритет будет зависеть только от порядка объявления правил в декларации.

Рассмотрим пример:

```html
<div class="header">
  <button class="button active">
</div>
```
Правила модификатора `active` для кнопки будут записаны как комбинированный селектор `.button.active`. При переопределении кнопки с помощью родительского блока `header`, будет создан селектор `.header .button`. Специфичность обоих селекторов одинакова, значит применение CSS-правил будет определяться их порядком в декларации.

Использование имени блока в названии модификатора обеспечивает более высокий приоритет CSS-правилам при переопределении блока. Селектор `.header .button` всегда будет иметь приоритет выше, чем `.button_active`.

>[Причины использования имени блока в имени модификатора](#short-mod-name)

<a name="block-name"></a>
## Почему нельзя писать `<div class="block_mod">` вместо `<div class="block block_mod">`, если имя модификатора уже содержит всю информацию о блоке?

Совмещение нескольких модификаторов на одном и том же блоке (например, `<div class="block_theme_christmas block_size_big">`) приведет к дублированию кода, реализующего базовую функциональность (логику и стили) блока.

<a name="tag-class-css"></a>
## Почему БЭМ не рекомендует объединять тег и класс в селекторе? Например, `button.button`.

Совмещение тега и класса в селекторе повышает специфичность CSS-правил. Это усложняет переопределение блока.

Рассмотрим пример:

```html
 <button class="button">
```

Записываем для него CSS-правила в селекторе `button.button`.

Добавим модификатор:

```html
 <button class="button button_active">
```

Cелектор `.button_mod` не переопределит свойства блока, записанные как `button.button`, так как специфичность `button.button` выше. Для успешного переопределения селектор модификатора блока также должен быть скомбинирован с тегом `button.button_mod`.

В результате развития проекта могут появится блоки с селекторами `input.button`, `span.button` и, например, `a.button`. В таком случае все модификаторы блока `button` и вложенные в него элементы потребуют четыре разные декларации для каждого случая.

<a name="global-mod"></a>
## Можно ли создавать глобальные модификаторы для блоков?

>Удобно создать общие правила для таких глобальных модификаторов, как как `visible`, `invisible`, `red`, `opacity50` в глобальном классе и применять его к разным блокам. Почему БЭМ это не использует?

В БЭМ отсутствует понятие глобальных модификаторов. Модификатор всегда относится к одной конкретной БЭМ-сущности.

Таким образом, если есть необходимость вынести какое-то свойство за пределы одного блока и применять его к разным БЭМ-сущностям в проекте, необходимо создавать отдельный блок. Такой блок может быть реализован только в технологии CSS.

Функционально БЭМ позволяет использовать несколько классов на одном DOM-узле и таким образом совмещать реализацию разных блоков. Такое объединение БЭМ-сущностей называется [миксом](../definitions/definitions.ru.md#mix):

```html
<div class="block1 opacity50"></div>
```

<a name="global-reset"></a>
## Почему БЭМ не рекомендует общий сброс стилей (reset)?

>Глобальный сброс стилей — общепринятая практика в веб-разработке. Многие фреймворки перед началом работы приводят все к общему виду, а потом накладывают свои классы.

Общий сброс стилей по сути реализуется с помощью [глобальных CSS-правил](#global-mod), которые в большинстве случаев пишутся к [селекторам на тег](#tag-css), что не подходит для БЭМ-методологии.

При необходимости в БЭМ применяется сброс стилей, но реализуется он для каждого блока отдельно. Так как блок — это независимый компонент страницы, который инкапсулирует в себе всё необходимое для своего функционирования и правильного отображения, его внешний вид не должен зависеть от CSS-правил, примененных ко всей веб-странице.

Рассмотрим пример. Если в проекте блоки меню и список в HTML выражены с помощью `<ul>`, значит каждый блок должен предоставлять сброс CSS для `<ul>`. Повторов в результирующем коде можно избежать с помощью CSS-оптимизатора.

Если в проекте не используется CSS-оптимизатор, который объединяет селекторы с одинаковым набором правил, можно применить CSS-препроцессор. Тогда для каждого нового блока можно делать сброс правил, миксуя чистый код. Например, в SASS это будет выглядеть так:

```
.menu {
    @include reset-list;
}
.menu__item {
    @include reset-list-item;
}
...
.list {
    @include reset-list;
}
.list__item {
    @include reset-list-item;
}
```

Такой способ следует использовать только при отсутствии оптимизатора.

<a name="tag-css"></a>
## Почему в БЭМ не используют пользовательские теги (custom tags) для формирования CSS-правил блока?

>Блоки могут выражаться в HTML с помощью пользовательских тегов, к которым создаются CSS-правила. В таком случае классы можно будет использовать только для модификаторов: `<button class="mod"/>`.

В БЭМ-методологии пользовательские теги могут применяться для создания селекторов к блокам. Однако такой подход имеет ряд ограничений:

* Зависимость от тега делает невозможным использование миксов — размещение нескольких БЭМ-сущностей на одном DOM-узле. В то время, как классы дают возможность свободно совмещать любые БЭМ-сущности: `<div class="block1 block2">`.
* Использование тегов не всегда позволяет выразить любой блок отдельным, уникальным тегом. Например, для всех ссылок необходим тег <a>, а для полей — <input>.

<a name="value-css"></a>
## Почему в названии модификатора не рекомендуется указывать предоставляемое им CSS-свойство (например, `.block__element_border-bottom_5px`)?

БЭМ-методология рекомендует выбирать семантически обоснованные имена для модификаторов, даже если они содержат только одно свойство.

Причины, по которым не следует указывать в названии модификатора его CSS-свойство:

* Изменение внешнего вида компонентов страницы повлекут за собой правки не только CSS-кода, но и названий селекторов и модификаторов. Например, если граница изменится с 5px до 6px, придется менять все шаблоны и, вполне вероятно, JavaScript-код.
* Наличие у модификатора только одного CSS-свойства — это скорее исключение, чем правило. Если модификатор отвечает только за размер границ блока, нет гарантий, что это не изменится. В будущем может понадобиться добавить дополнительные свойства. Например, выставление этого модификатора будет влиять на фон и отступы. В таком случае имя модификатора `_border-bottom_5px` не будет соответствовать действительности.
